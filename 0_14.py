import curses
import re
from curses import textpad
from enum import Enum, auto

# ==============================================================================
#  1. C++ Template & Python Object Model
# ==============================================================================

CPP_TEMPLATE = """
#include <Arduino.h>

// =============================================================================
// == DATA STRUCTURES & COLORS
// =============================================================================

// Add a value of 10 for bold effect (e.g., FG_RED + 10 = bold red)
#define FG_BLACK 30
#define FG_RED 31
#define FG_GREEN 32
#define FG_YELLOW 33
#define FG_BLUE 34
#define FG_MAGENTA 35
#define FG_CYAN 36
#define FG_WHITE 37

struct Box { int16_t x, y, w, h; uint8_t color; };
struct Text { int16_t x, y; const char* content; uint8_t color; };
struct Line { int16_t x1, y1, x2, y2; uint8_t color; };
struct Freehand { int16_t x, y; const char** lines; uint8_t line_count; uint8_t color; };

// =============================================================================
// == LOW-LEVEL RENDERING
// =============================================================================
void moveCursor(int16_t x, int16_t y) {
  Serial.print("\\033["); Serial.print(y + 1); Serial.print(";");
  Serial.print(x + 1); Serial.print("H");
}

void setColor(uint8_t color) {
  if (color == 0) { // Color 0 is default/reset
    Serial.print("\\033[0m");
    return;
  }
  if (color >= 40) { // Bold colors
    Serial.print("\\033[1;"); // Bold
    Serial.print(color - 10);
  } else {
    Serial.print("\\033[0;"); // Not bold
    Serial.print(color);
  }
  Serial.print("m");
}

void clearScreen() { Serial.print("\\033[2J\\033[H"); }

// =============================================================================
// == HIGH-LEVEL DRAWING (OPTIMIZED)
// =============================================================================
void draw(const Box& box) {
  setColor(box.color);
  // Optimized: draw full horizontal lines at once to reduce cursor moves
  char* h_line = (char*) malloc(box.w - 1);
  if (h_line) {
    memset(h_line, '-', box.w - 2);
    h_line[0] = '+';
    h_line[box.w - 2] = '+';
    h_line[box.w - 1] = '\\0';
    moveCursor(box.x, box.y); Serial.print(h_line);
    moveCursor(box.x, box.y + box.h - 1); Serial.print(h_line);
    free(h_line);
  }
  // Draw vertical lines
  for (int16_t i = 1; i < box.h - 1; ++i) {
    moveCursor(box.x, box.y + i); Serial.print("|");
    moveCursor(box.x + box.w - 1, box.y + i); Serial.print("|");
  }
  setColor(0); // Reset color
}

void draw(const Text& text) {
  setColor(text.color);
  moveCursor(text.x, text.y);
  Serial.print(text.content);
  setColor(0);
}

void draw(const Line& line) {
  setColor(line.color);
  int16_t x1 = line.x1, y1 = line.y1;
  const int16_t x2 = line.x2, y2 = line.y2;
  int16_t dx = abs(x2 - x1), sx = x1 < x2 ? 1 : -1;
  int16_t dy = -abs(y2 - y1), sy = y1 < y2 ? 1 : -1;
  int16_t err = dx + dy, e2;
  while (true) {
    moveCursor(x1, y1); Serial.print("#");
    if (x1 == x2 && y1 == y2) break;
    e2 = 2 * err;
    if (e2 >= dy) { err += dy; x1 += sx; }
    if (e2 <= dx) { err += dx; y1 += sy; }
  }
  setColor(0);
}

void draw(const Freehand& art) {
  setColor(art.color);
  for (uint8_t i = 0; i < art.line_count; ++i) {
    moveCursor(art.x, art.y + i);
    Serial.print(art.lines[i]);
  }
  setColor(0);
}

// =============================================================================
// == UI SCREEN DEFINITIONS (Generated by Python)
// =============================================================================
// [[SCREEN_FUNCTIONS_PLACEHOLDER]]

// =============================================================================
// == ARDUINO SETUP & LOOP
// =============================================================================
// Optional: Define an enum for your screens for cleaner code
// enum Screen { MAIN_MENU, SETTINGS };
// Screen currentScreen = MAIN_MENU;

void setup() {
  Serial.begin(115200); // Using a faster baud rate
  while (!Serial) { delay(10); }
  delay(1000);
  Serial.print("\\033[?25l"); // Hide cursor
  clearScreen();
  // [[INITIAL_SCREEN_CALL_PLACEHOLDER]]
}

void loop() {
  // EXAMPLE: Simple screen manager. Type '1' or '2' in Serial Monitor.
  // if (Serial.available() > 0) {
  //   char command = Serial.read();
  //   clearScreen();
  //   if (command == '1') {
  //     // [[SCREEN_1_CALL_PLACEHOLDER]]
  //   } else if (command == '2') {
  //     // [[SCREEN_2_CALL_PLACEHOLDER]]
  //   }
  // }
  delay(100);
}
"""

class DesignMode(Enum):
    NAVIGATE = auto()
    PROMPT = auto()
    DRAW_BOX_START = auto()
    DRAW_BOX_END = auto()
    DRAW_LINE_START = auto()
    DRAW_LINE_END = auto()
    GET_TEXT = auto()
    GET_FREEHAND = auto()
    SWITCH_SCREEN = auto()

class DrawableObject:
    def __init__(self, obj_type, name, data, color_pair=1):
        if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', name):
            raise ValueError(f"Object name '{name}' is not a valid C++ identifier.")
        self.obj_type = obj_type
        self.name = name
        self.data = data
        self.color_pair = color_pair
        self.color_map = {1: 37, 2: 31, 3: 32, 4: 33, 5: 34, 6: 35, 7: 36} # Maps curses pair to FG color

    def to_cpp_declaration(self):
    def cpp_escape(s: str) -> str:
        """Escape a Python string into a safe C++ string literal."""
        return (
            s.replace("\\", "\\\\")   # escape backslashes first
             .replace("\"", "\\\"")   # escape double quotes
             .replace("\n", "\\n")    # escape newlines
             .replace("\r", "\\r")    # escape carriage returns
        )

    color = self.color_map.get(self.color_pair, 37)  # Default to white

    if self.obj_type == "box":
        x, y, w, h = self.data
        return f"  Box {self.name} = {{{x}, {y}, {w}, {h}, {color}}};"

    elif self.obj_type == "text":
        x, y, txt = self.data
        escaped_txt = cpp_escape(txt)
        return f'  Text {self.name} = {{{x}, {y}, "{escaped_txt}", {color}}};'

    elif self.obj_type == "line":
        x1, y1, x2, y2 = self.data
        return f"  Line {self.name} = {{{x1}, {y1}, {x2}, {y2}, {color}}};"

    elif self.obj_type == "freehand":
        x, y, lines = self.data
        lines_array_name = f"{self.name}_lines"

        # Escape each string safely for C++
        escaped_lines = [f"\"{cpp_escape(line)}\"" for line in lines]

        # Build array declaration
        lines_decl = f"const char* {lines_array_name}[] = {{{', '.join(escaped_lines)}}};"

        struct_decl = f"Freehand {self.name} = {{{x}, {y}, {lines_array_name}, {len(lines)}, {color}}};"
        return f"  {lines_decl}\n  {struct_decl}"

    return ""


    def to_cpp_draw_call(self):
        return f"  draw({self.name});"

    def draw_on_canvas(self, stdscr, is_selected):
        attr = curses.A_BOLD if is_selected else curses.A_NORMAL
        color = curses.color_pair(self.color_pair) | attr
        try:
            if self.obj_type == "box":
                x, y, w, h = self.data
                stdscr.addch(y, x, '+', color)
                stdscr.addch(y, x + w - 1, '+', color)
                stdscr.addch(y + h - 1, x, '+', color)
                stdscr.addch(y + h - 1, x + w - 1, '+', color)
                for i in range(1, w - 1):
                    stdscr.addch(y, x + i, '-', color)
                    stdscr.addch(y + h - 1, x + i, '-', color)
                for i in range(1, h - 1):
                    stdscr.addch(y + i, x, '|', color)
                    stdscr.addch(y + i, x + w - 1, '|', color)
            elif self.obj_type == "text":
                x, y, content = self.data
                stdscr.addstr(y, x, content, color)
            elif self.obj_type == "line":
                x1, y1, x2, y2 = self.data
                dx, sx = abs(x2 - x1), 1 if x1 < x2 else -1
                dy, sy = -abs(y2 - y1), 1 if y1 < y2 else -1
                err = dx + dy
                x, y = x1, y1
                while True:
                    stdscr.addch(y, x, '#', color)
                    if x == x2 and y == y2: break
                    e2 = 2 * err
                    if e2 >= dy: err += dy; x += sx
                    if e2 <= dx: err += dx; y += sy
            elif self.obj_type == "freehand":
                x, y, lines = self.data
                for i, line in enumerate(lines):
                    stdscr.addstr(y + i, x, line, color)
        except curses.error: pass # Ignore drawing off-screen

    def update_position(self, dx, dy):
        if self.obj_type in ["box", "text", "freehand"]:
            x, y, *rest = self.data
            self.data = (x + dx, y + dy, *rest)
        elif self.obj_type == "line":
            x1, y1, x2, y2 = self.data
            self.data = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)

# ==============================================================================
#  2. Interactive Designer Class
# ==============================================================================

class Designer:
    def __init__(self, stdscr):
        self.stdscr = stdscr
        self.cursor_x, self.cursor_y = 0, 0
        self.screens = {}
        self.current_screen_name = None
        self.objects = []
        self.mode = DesignMode.NAVIGATE
        self.status = "Welcome! Press 'n' for a new screen, 'q' to quit."
        self.temp_data = {}
        self.selected_object_index = -1

    def run(self):
        curses.start_color()
        curses.use_default_colors()
        # Init color pairs: ID, FG, BG (-1 is transparent)
        curses.init_pair(1, curses.COLOR_WHITE, -1)
        curses.init_pair(2, curses.COLOR_RED, -1)
        curses.init_pair(3, curses.COLOR_GREEN, -1)
        curses.init_pair(4, curses.COLOR_YELLOW, -1)
        curses.init_pair(5, curses.COLOR_BLUE, -1)
        curses.init_pair(6, curses.COLOR_MAGENTA, -1)
        curses.init_pair(7, curses.COLOR_CYAN, -1)
        
        self.stdscr.clear()
        
        while True:
            self._draw_ui()
            key = self.stdscr.getch()
            if not self._handle_input(key): break

    def _get_selected_object(self):
        if self.selected_object_index != -1 and self.objects:
            return self.objects[self.selected_object_index]
        return None
        
    def _handle_input(self, key):
        # Handle mode-specific actions first
        if self.mode in [DesignMode.DRAW_BOX_END, DesignMode.DRAW_LINE_END]:
            if key in [10, 13, curses.KEY_ENTER]:
                self._finish_drawing()
            elif key == 27: # Escape
                self._cancel_drawing()
            else:
                self._handle_navigation(key)
        elif self.mode == DesignMode.NAVIGATE:
            if key in [10, 13, curses.KEY_ENTER]:
                self._handle_enter_key()
            elif key == ord('q'): return False
            elif key == ord('n'): self._new_screen()
            elif key == ord('m'): self._switch_screen()
            elif key == ord('s'): self._save_and_compile()
            elif key == ord('\t'): self._select_next_object()
            elif key == 27: # Escape
                self.selected_object_index = -1
            elif key in [curses.KEY_UP, curses.KEY_DOWN, curses.KEY_LEFT, curses.KEY_RIGHT]:
                self._handle_navigation(key)
            elif key in [curses.KEY_DC, ord('d')]: self._delete_selected_object()
            elif key == ord('c'): self._change_selected_color()
            elif key == ord('+'): self._change_layer(1)
            elif key == ord('-'): self._change_layer(-1)
            elif key == ord('b'): self._start_drawing("box")
            elif key == ord('l'): self._start_drawing("line")
            elif key == ord('t'): self._get_text_from_user()
            elif key == ord('f'): self._get_freehand_from_user()
        
        self._update_status()
        return True

    def _handle_navigation(self, key):
        selected_obj = self._get_selected_object()
        if key == curses.KEY_UP:
            if selected_obj: selected_obj.update_position(0, -1)
            else: self.cursor_y = max(0, self.cursor_y - 1)
        elif key == curses.KEY_DOWN:
            if selected_obj: selected_obj.update_position(0, 1)
            else: self.cursor_y += 1
        elif key == curses.KEY_LEFT:
            if selected_obj: selected_obj.update_position(-1, 0)
            else: self.cursor_x = max(0, self.cursor_x - 1)
        elif key == curses.KEY_RIGHT:
            if selected_obj: selected_obj.update_position(1, 0)
            else: self.cursor_x += 1
    
    def _handle_enter_key(self):
        if self.mode == DesignMode.DRAW_BOX_START:
            self.mode = DesignMode.DRAW_BOX_END
            self.temp_data['x1'], self.temp_data['y1'] = self.cursor_x, self.cursor_y
            self.status = "Move to end point and press Enter."
        elif self.mode == DesignMode.DRAW_LINE_START:
            self.mode = DesignMode.DRAW_LINE_END
            self.temp_data['x1'], self.temp_data['y1'] = self.cursor_x, self.cursor_y
            self.status = "Move to end point and press Enter."
            
    def _update_status(self):
        actions = ""
        if self.mode == DesignMode.NAVIGATE:
            if self._get_selected_object():
                actions = "MOVE with arrows | (d)elete (c)olor (+/-)layer | (ESC) deselect | (TAB) next object"
            else:
                actions = "Draw: (b)ox (l)ine (t)ext (f)reehand | (n)ew screen (m)anage screens (s)ave | (TAB) select object"
        elif self.mode in [DesignMode.DRAW_BOX_START, DesignMode.DRAW_LINE_START]:
            actions = "Press ENTER to set start point, ESC to cancel."
        elif self.mode in [DesignMode.DRAW_BOX_END, DesignMode.DRAW_LINE_END]:
            actions = "Move cursor to end point, press ENTER to finish, ESC to cancel."
        self.status = actions

    def _prompt(self, prompt_text):
        self.mode = DesignMode.PROMPT
        h, w = self.stdscr.getmaxyx()
        self.stdscr.addstr(h - 1, 0, prompt_text.ljust(w - 1), curses.A_REVERSE)
        editwin = curses.newwin(1, w - len(prompt_text) - 2, h - 1, len(prompt_text) + 1)
        self.stdscr.refresh()
        box = textpad.Textbox(editwin, insert_mode=True)
        # Fix for textpad to exit on Enter, not just newline.
        def validator(key):
            if key in [10, 13]: return 7 # ASCII bell character to exit textpad.edit()
            return key
        box.edit(validator)
        self.mode = DesignMode.NAVIGATE
        return box.gather().strip()

    def _select_next_object(self):
        if not self.objects: return
        self.selected_object_index = (self.selected_object_index + 1) % len(self.objects)

    def _delete_selected_object(self):
        if self._get_selected_object():
            del self.objects[self.selected_object_index]
            self.selected_object_index = -1

    def _change_selected_color(self):
        if obj := self._get_selected_object():
            obj.color_pair = (obj.color_pair % 7) + 1

    def _change_layer(self, direction):
        if obj := self._get_selected_object():
            idx = self.selected_object_index
            new_idx = idx + direction
            if 0 <= new_idx < len(self.objects):
                self.objects.insert(new_idx, self.objects.pop(idx))
                self.selected_object_index = new_idx
                
    def _start_drawing(self, shape):
        self.temp_data.clear()
        if shape == "box": self.mode = DesignMode.DRAW_BOX_START
        elif shape == "line": self.mode = DesignMode.DRAW_LINE_START
        self.status = f"{shape.upper()} MODE: Press Enter to set start point."

    def _cancel_drawing(self):
        self.mode = DesignMode.NAVIGATE
        self.temp_data.clear()
        self.status = "Drawing cancelled."

    def _finish_drawing(self):
        x1, y1 = self.temp_data['x1'], self.temp_data['y1']
        x2, y2 = self.cursor_x, self.cursor_y
        
        name = self._get_object_name(self.mode.name.split('_')[1])
        if not name:
            self._cancel_drawing()
            return

        if self.mode == DesignMode.DRAW_BOX_END:
            x, y = min(x1, x2), min(y1, y2)
            w, h = abs(x1 - x2) + 1, abs(y1 - y2) + 1
            self.objects.append(DrawableObject("box", name, (x, y, w, h)))
        elif self.mode == DesignMode.DRAW_LINE_END:
            self.objects.append(DrawableObject("line", name, (x1, y1, x2, y2)))
        
        self.mode = DesignMode.NAVIGATE
        self.temp_data.clear()
        self.selected_object_index = len(self.objects) - 1 # Select the new object

    def _get_object_name(self, obj_type):
        while True:
            name = self._prompt(f"Enter C++ variable name for new {obj_type}: ")
            if not name: return None
            if re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', name): return name
            self._prompt("Invalid name. Use C++ rules (e.g. myButton). Press Enter.")
            
    def _new_screen(self):
        if self.current_screen_name: self.screens[self.current_screen_name] = self.objects
        name = self._prompt("New screen name: ")
        if name:
            self.current_screen_name = name
            self.objects = self.screens.get(name, [])
            self.selected_object_index = -1

    def _switch_screen(self):
        self.mode = DesignMode.SWITCH_SCREEN
        if not self.screens:
            self.status = "No other screens exist. Create one with 'n'."
            self.mode = DesignMode.NAVIGATE
            return
        
        self.stdscr.clear()
        self.stdscr.addstr(0, 0, "Select a screen to edit:", curses.A_REVERSE)
        for i, name in enumerate(self.screens.keys()):
            self.stdscr.addstr(i + 2, 2, f"{i+1}. {name}")
        self.stdscr.refresh()
        
        key = self.stdscr.getch()
        if '1' <= chr(key) <= str(len(self.screens)):
            idx = int(chr(key)) - 1
            if self.current_screen_name: self.screens[self.current_screen_name] = self.objects
            self.current_screen_name = list(self.screens.keys())[idx]
            self.objects = self.screens[self.current_screen_name]
            self.selected_object_index = -1
        
        self.mode = DesignMode.NAVIGATE
        self.stdscr.clear()

    def _get_text_from_user(self):
        content = self._prompt(f"Enter text at ({self.cursor_x}, {self.cursor_y}): ")
        if content:
            name = self._get_object_name("text")
            if name: self.objects.append(DrawableObject("text", name, (self.cursor_x, self.cursor_y, content)))

    def _get_freehand_from_user(self):
        lines = []
        self.mode = DesignMode.GET_FREEHAND
        while True:
            line = self._prompt(f"Freehand Line {len(lines)+1} ('END' to finish):")
            if line.upper() == 'END': break
            lines.append(line)
        if lines:
            name = self._get_object_name("freehand art")
            if name: self.objects.append(DrawableObject("freehand", name, (self.cursor_x, self.cursor_y, lines)))
        self.mode = DesignMode.NAVIGATE

    def _draw_ui(self):
        self.stdscr.clear()
        
        for i, obj in enumerate(self.objects):
            obj.draw_on_canvas(self.stdscr, i == self.selected_object_index)

        # Draw previews
        if self.mode == DesignMode.DRAW_BOX_END:
            x1, y1 = self.temp_data['x1'], self.temp_data['y1']
            textpad.rectangle(self.stdscr, min(y1, self.cursor_y), min(x1, self.cursor_x), max(y1, self.cursor_y), max(x1, self.cursor_x))
        elif self.mode == DesignMode.DRAW_LINE_END:
            temp_line = DrawableObject('line', 'temp', (self.temp_data['x1'], self.temp_data['y1'], self.cursor_x, self.cursor_y))
            temp_line.draw_on_canvas(self.stdscr, True)

        # Status Bar and Cursor
        h, w = self.stdscr.getmaxyx()
        pos_str = f"Pos:({self.cursor_x},{self.cursor_y}) | Screen: {self.current_screen_name or 'None'} | {self.status}"
        self.stdscr.addstr(h - 1, 0, pos_str.ljust(w-1), curses.A_REVERSE)
        
        if self.mode not in [DesignMode.PROMPT, DesignMode.SWITCH_SCREEN]:
            curses.curs_set(1)
            self.stdscr.move(self.cursor_y, self.cursor_x)
        else:
            curses.curs_set(0) # Hide cursor in prompt/menu mode

        self.stdscr.refresh()

    def _save_and_compile(self):
        if self.current_screen_name: self.screens[self.current_screen_name] = self.objects
        if not self.screens:
            self.status = "Error: No screens to save. Create one with 'n'."
            return
        try:
            compile_to_cpp(self.screens)
            self.status = f"✅ COMPILED successfully! Press 'q' to exit."
        except Exception as e:
            self.status = f"❌ COMPILE FAILED: {e}"

# ==============================================================================
#  3. Code Generation Logic
# ==============================================================================

def compile_to_cpp(screens, filename="ui_generated.ino"):
    if not screens: raise ValueError("No screens defined.")
    
    screen_functions_code = []
    screen_names = list(screens.keys())
    for name in screen_names:
        function_name = f"drawScreen_{re.sub(r'[^a-zA-Z0-9_]', '', name)}"
        screen_functions_code.append(f"void {function_name}() {{")
        objects = screens[name]
        for obj in objects: screen_functions_code.append(obj.to_cpp_declaration())
        screen_functions_code.append("")
        for obj in objects: screen_functions_code.append(obj.to_cpp_draw_call())
        screen_functions_code.append("}\n")
    
    final_code = CPP_TEMPLATE.replace("// [[SCREEN_FUNCTIONS_PLACEHOLDER]]", "\n".join(screen_functions_code))
    
    # Populate screen call placeholders
    initial_call = f"drawScreen_{re.sub(r'[^a-zA-Z0-9_]', '', screen_names[0])}();"
    final_code = final_code.replace("// [[INITIAL_SCREEN_CALL_PLACEHOLDER]]", initial_call)
    
    if len(screen_names) > 0:
        call_1 = f"drawScreen_{re.sub(r'[^a-zA-Z0-9_]', '', screen_names[0])}();"
        final_code = final_code.replace("// [[SCREEN_1_CALL_PLACEHOLDER]]", call_1)
    if len(screen_names) > 1:
        call_2 = f"drawScreen_{re.sub(r'[^a-zA-Z0-9_]', '', screen_names[1])}();"
        final_code = final_code.replace("// [[SCREEN_2_CALL_PLACEHOLDER]]", call_2)
    
    with open(filename, "w") as f: f.write(final_code)

# ==============================================================================
#  4. Main Execution
# ==============================================================================

if __name__ == "__main__":
    print("Starting Arduino Serial UI Designer...")
    try:
        curses.wrapper(lambda stdscr: Designer(stdscr).run())
        print("\nDesigner closed. If saved, 'ui_generated.ino' is ready.")
    except curses.error as e:
        print(f"\nCurses error: {e}")
        print("Your terminal window may be too small.")
    except Exception as e:
        print(f"\nAn error occurred: {e}")
        print("On Windows, you might need to install 'windows-curses' via: pip install windows-curses")
