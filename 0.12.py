import curses
import re
from curses import textpad

# ==============================================================================
#  1. C++ Template & Python Object Model
# ==============================================================================
# This section defines the target C++ code structure and the Python classes
# that represent the UI elements.

CPP_TEMPLATE = """
#include <Arduino.h>

// =============================================================================
// == DATA STRUCTURES: Define the properties for each UI object type.
// =============================================================================
struct Box { int16_t x, y, w, h; };
struct Text { int16_t x, y; const char* content; };
struct Freehand { int16_t x, y; const char** lines; uint8_t line_count; };
// Add other object structs here (e.g., Line, Circle)

// =============================================================================
// == LOW-LEVEL RENDERING: Basic functions to control the serial terminal.
// =============================================================================
void moveCursor(int16_t x, int16_t y) {
  Serial.print("\\033["); Serial.print(y + 1); Serial.print(";");
  Serial.print(x + 1); Serial.print("H");
}

void clearScreen() { Serial.print("\\033[2J\\033[H"); }

// =============================================================================
// == HIGH-LEVEL DRAWING: Overloaded functions to draw each object type.
// =============================================================================
void draw(const Box& box) {
  for (int16_t i = 1; i < box.w - 1; ++i) {
    moveCursor(box.x + i, box.y); Serial.print("-");
    moveCursor(box.x + i, box.y + box.h - 1); Serial.print("-");
  }
  for (int16_t i = 1; i < box.h - 1; ++i) {
    moveCursor(box.x, box.y + i); Serial.print("|");
    moveCursor(box.x + box.w - 1, box.y + i); Serial.print("|");
  }
  moveCursor(box.x, box.y); Serial.print("+");
  moveCursor(box.x + box.w - 1, box.y); Serial.print("+");
  moveCursor(box.x, box.y + box.h - 1); Serial.print("+");
  moveCursor(box.x + box.w - 1, box.y + box.h - 1); Serial.print("+");
}

void draw(const Text& text) {
  moveCursor(text.x, text.y);
  Serial.print(text.content);
}

void draw(const Freehand& art) {
  for (uint8_t i = 0; i < art.line_count; ++i) {
    moveCursor(art.x, art.y + i);
    Serial.print(art.lines[i]);
  }
}

// =============================================================================
// == UI SCREEN DEFINITIONS (Generated by Python)
// =============================================================================
// [[SCREEN_FUNCTIONS_PLACEHOLDER]]

// =============================================================================
// == ARDUINO SETUP & LOOP
// =============================================================================
void setup() {
  Serial.begin(9600);
  while (!Serial) { delay(10); }
  delay(1000);
  Serial.print("\\033[?25l"); // Hide cursor
  clearScreen();
  // [[INITIAL_SCREEN_CALL_PLACEHOLDER]]
}

void loop() { /* User logic here */ }
"""

class DrawableObject:
    """Represents a single drawable UI element and knows how to generate its C++ code."""
    def __init__(self, obj_type, name, data):
        if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', name):
            raise ValueError(f"Object name '{name}' is not a valid C++ identifier.")
        self.obj_type = obj_type
        self.name = name
        self.data = data

    def to_cpp_declaration(self):
        """Generates the C++ code to declare and initialize the object's struct."""
        if self.obj_type == "box":
            x, y, w, h = self.data
            return f"  Box {self.name} = {{{x}, {y}, {w}, {h}}};"
        elif self.obj_type == "text":
            x, y, txt = self.data
            escaped_txt = txt.replace('"', '\\"')
            return f'  Text {self.name} = {{{x}, {y}, "{escaped_txt}"}};'
        elif self.obj_type == "freehand":
            x, y, lines = self.data
            lines_array_name = f"{self.name}_lines"
            lines_declaration = f"const char* {lines_array_name}[] = {{{', '.join(f'\"{line.replace("\"", "\\\"")}\"' for line in lines)}}};"
            struct_declaration = f"Freehand {self.name} = {{{x}, {y}, {lines_array_name}, {len(lines)}}};"
            return f"  {lines_declaration}\n  {struct_declaration}"
        return "  // Unsupported object type"

    def to_cpp_draw_call(self):
        return f"  draw({self.name});"

# ==============================================================================
#  2. Interactive Designer Class
# ==============================================================================
# This class manages the entire 'curses' based interactive design session.

class Designer:
    def __init__(self, stdscr):
        self.stdscr = stdscr
        self.cursor_x, self.cursor_y = 0, 0
        self.screens = {}
        self.current_screen_name = None
        self.objects = []
        self.mode = "navigate"
        self.status = "Welcome! Press 'n' for a new screen, 'q' to quit."
        self.temp_data = {}

    def run(self):
        """Main application loop for the designer."""
        curses.curs_set(1)  # Show cursor
        self.stdscr.clear()
        
        while True:
            self._draw_ui()
            key = self.stdscr.getch()
            if not self._handle_input(key):
                break # Exit loop if handler returns False

    def _handle_input(self, key):
        """Processes user keyboard input."""
        if self.mode in ["prompt", "get_text", "get_freehand"]: return True

        # Global keys
        if key == ord('q'): return False
        elif key == ord('n'): self._new_screen()
        elif key == ord('s'): self._save_and_compile()
        # Navigation
        elif key == curses.KEY_UP: self.cursor_y = max(0, self.cursor_y - 1)
        elif key == curses.KEY_DOWN: self.cursor_y += 1
        elif key == curses.KEY_LEFT: self.cursor_x = max(0, self.cursor_x - 1)
        elif key == curses.KEY_RIGHT: self.cursor_x += 1
        # Drawing mode keys
        elif key == ord('b'): self._start_drawing_box()
        elif key == ord('t'): self._get_text_from_user()
        elif key == ord('f'): self._get_freehand_from_user()
        elif key == 27: # Escape key
            self.mode = "navigate"
            self.status = "Drawing cancelled. (b)ox, (t)ext, (f)reehand, (s)ave, (q)uit"

        # Context-sensitive Enter key
        elif key in [10, 13, curses.KEY_ENTER]:
            if self.mode == "draw_box_start": self._set_box_corner()
            elif self.mode == "draw_box_end": self._finish_drawing_box()

        return True

    def _prompt(self, prompt_text):
        """Displays a prompt and returns user input."""
        self.mode = "prompt"
        h, w = self.stdscr.getmaxyx()
        self.stdscr.addstr(h - 1, 0, prompt_text.ljust(w - 1), curses.A_REVERSE)
        editwin = curses.newwin(1, w - len(prompt_text) - 2, h - 1, len(prompt_text) + 1)
        self.stdscr.refresh()
        box = textpad.Textbox(editwin)
        box.edit()
        self.mode = "navigate"
        return box.gather().strip()

    def _new_screen(self):
        # Save current screen if it exists
        if self.current_screen_name and self.objects:
            self.screens[self.current_screen_name] = self.objects
        
        name = self._prompt("New screen name: ")
        if name:
            self.current_screen_name = name
            self.objects = []
            self.status = f"Editing screen '{name}'. (b)ox, (t)ext, (f)reehand, (s)ave, (q)uit"

    def _get_object_name(self, obj_type):
        while True:
            name = self._prompt(f"Enter C++ variable name for new {obj_type}: ")
            if re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', name):
                return name
            self.status = "Invalid name. Use C++ identifier rules (e.g., 'myButton')."
            self._draw_status() # Redraw status immediately to show error
            
    def _start_drawing_box(self):
        self.mode = "draw_box_start"
        self.status = "BOX MODE: Press Enter to set the first corner."

    def _set_box_corner(self):
        self.temp_data['x1'] = self.cursor_x
        self.temp_data['y1'] = self.cursor_y
        self.mode = "draw_box_end"
        self.status = "BOX MODE: Move to the opposite corner and press Enter to finish."
        
    def _finish_drawing_box(self):
        x1, y1 = self.temp_data['x1'], self.temp_data['y1']
        x2, y2 = self.cursor_x, self.cursor_y
        x = min(x1, x2)
        y = min(y1, y2)
        w = abs(x1 - x2) + 1
        h = abs(y1 - y2) + 1
        name = self._get_object_name("box")
        self.objects.append(DrawableObject("box", name, (x, y, w, h)))
        self.mode = "navigate"
        self.status = f"Box '{name}' created. (b)ox, (t)ext, (f)reehand, (s)ave, (q)uit"

    def _get_text_from_user(self):
        self.mode = "get_text"
        content = self._prompt(f"Enter text to place at ({self.cursor_x}, {self.cursor_y}): ")
        if content:
            name = self._get_object_name("text")
            self.objects.append(DrawableObject("text", name, (self.cursor_x, self.cursor_y, content)))
            self.status = f"Text '{name}' created. (b)ox, (t)ext, (f)reehand, (s)ave, (q)uit"
        else:
             self.status = "Text entry cancelled."
        self.mode = "navigate"

    def _get_freehand_from_user(self):
        self.mode = "get_freehand"
        lines = []
        h, w = self.stdscr.getmaxyx()
        self.status = "FREEHAND MODE: Enter art line-by-line. Type 'END' on a new line to finish."
        self._draw_status()
        self.stdscr.move(0,0) # Move cursor out of the way
        
        while True:
            line = self._prompt(f"Line {len(lines)+1}: ")
            if line.upper() == 'END': break
            lines.append(line)
        
        if lines:
            name = self._get_object_name("freehand art")
            self.objects.append(DrawableObject("freehand", name, (self.cursor_x, self.cursor_y, lines)))
            self.status = f"Freehand '{name}' created. (b)ox, (t)ext, (f)reehand, (s)ave, (q)uit"
        else:
            self.status = "Freehand entry cancelled."
        self.mode = "navigate"
        
    def _draw_ui(self):
        """Redraws the entire designer interface on each loop."""
        self.stdscr.clear()
        h, w = self.stdscr.getmaxyx()
        
        # Draw all permanent objects for the current screen
        for obj in self.objects:
            self._draw_object_on_canvas(obj)

        # Draw previews for operations in progress
        if self.mode == 'draw_box_end':
            self._draw_preview_box()
            
        # Draw status bar and cursor
        self._draw_status()
        self.stdscr.move(self.cursor_y, self.cursor_x)
        self.stdscr.refresh()

    def _draw_status(self):
        h, w = self.stdscr.getmaxyx()
        status_line = f" Pos:({self.cursor_x},{self.cursor_y}) | Screen: {self.current_screen_name or 'None'} | {self.status}"
        self.stdscr.addstr(h - 1, 0, status_line.ljust(w-1), curses.A_REVERSE)

    def _draw_object_on_canvas(self, obj):
        try:
            if obj.obj_type == "box":
                x, y, w, h = obj.data
                textpad.rectangle(self.stdscr, y, x, y + h - 1, x + w - 1)
            elif obj.obj_type == "text":
                x, y, content = obj.data
                self.stdscr.addstr(y, x, content)
            elif obj.obj_type == "freehand":
                x, y, lines = obj.data
                for i, line in enumerate(lines):
                    self.stdscr.addstr(y + i, x, line)
        except curses.error:
            pass # Ignore errors from drawing off-screen

    def _draw_preview_box(self):
        x1, y1 = self.temp_data['x1'], self.temp_data['y1']
        x2, y2 = self.cursor_x, self.cursor_y
        try:
            textpad.rectangle(self.stdscr, min(y1, y2), min(x1, x2), max(y1, y2), max(x1, x2))
        except curses.error:
            pass

    def _save_and_compile(self):
        if self.current_screen_name:
            self.screens[self.current_screen_name] = self.objects
        
        if not self.screens:
            self.status = "Error: No screens to save. Create one with 'n'."
            return
        
        try:
            compile_to_cpp(self.screens)
            self.status = "✅ COMPILED successfully to 'ui_generated.ino'! Press 'q' to exit."
        except Exception as e:
            self.status = f"❌ COMPILE FAILED: {e}"

# ==============================================================================
#  3. Code Generation Logic
# ==============================================================================

def compile_to_cpp(screens, filename="ui_generated.ino"):
    if not screens: raise ValueError("No screens defined.")
    
    screen_functions_code = []
    for screen_name, objects in screens.items():
        function_name = f"drawScreen_{re.sub(r'[^a-zA-Z0-9_]', '', screen_name)}"
        screen_functions_code.append(f"void {function_name}() {{")
        
        # Add declarations first
        for obj in objects: screen_functions_code.append(obj.to_cpp_declaration())
        screen_functions_code.append("")
        # Add draw calls
        for obj in objects: screen_functions_code.append(obj.to_cpp_draw_call())
        screen_functions_code.append("}\n")
    
    initial_screen_name = next(iter(screens))
    initial_call = f"drawScreen_{re.sub(r'[^a-zA-Z0-9_]', '', initial_screen_name)}();"
    
    final_code = CPP_TEMPLATE.replace("// [[SCREEN_FUNCTIONS_PLACEHOLDER]]", "\n".join(screen_functions_code))
    final_code = final_code.replace("// [[INITIAL_SCREEN_CALL_PLACEHOLDER]]", initial_call)
    
    with open(filename, "w") as f: f.write(final_code)

# ==============================================================================
#  4. Main Execution
# ==============================================================================

if __name__ == "__main__":
    try:
        curses.wrapper(lambda stdscr: Designer(stdscr).run())
        print("\nDesigner closed. Arduino sketch 'ui_generated.ino' is ready if saved.")
    except Exception as e:
        print(f"\nAn error occurred: {e}")
        print("If you are on Windows, try installing 'windows-curses' via pip.")
