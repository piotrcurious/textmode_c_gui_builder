import sys
import re

# ==============================================================================
#  1. C++ Template for the Arduino Sketch
# ==============================================================================
# This template contains the foundational C++ code. The Python script will
# inject the UI object definitions and screen-drawing functions into it.

CPP_TEMPLATE = """
#include <Arduino.h>

// =============================================================================
// == DATA STRUCTURES: Define the properties for each UI object type.
// =============================================================================
struct Box { int16_t x, y, w, h; };
struct Line { int16_t x1, y1, x2, y2; };
struct Text { int16_t x, y; const char* content; };
// Add other object structs here (e.g., Circle, Arc)

// =============================================================================
// == LOW-LEVEL RENDERING: Basic functions to control the serial terminal.
// =============================================================================

// Moves the cursor to a specific (x, y) position using VT102 escape codes.
void moveCursor(int16_t x, int16_t y) {
  Serial.print("\\033[");
  Serial.print(y + 1); // Terminal coordinates are 1-based.
  Serial.print(";");
  Serial.print(x + 1);
  Serial.print("H");
}

// Clears the entire terminal screen.
void clearScreen() {
  Serial.print("\\033[2J\\033[H");
}

// =============================================================================
// == HIGH-LEVEL DRAWING: Overloaded functions to draw each object type.
// =============================================================================

// Draws a box with corners.
void draw(const Box& box) {
  // Draw horizontal lines
  for (int16_t i = 1; i < box.w - 1; ++i) {
    moveCursor(box.x + i, box.y); Serial.print("-");
    moveCursor(box.x + i, box.y + box.h - 1); Serial.print("-");
  }
  // Draw vertical lines
  for (int16_t i = 1; i < box.h - 1; ++i) {
    moveCursor(box.x, box.y + i); Serial.print("|");
    moveCursor(box.x + box.w - 1, box.y + i); Serial.print("|");
  }
  // Draw corners
  moveCursor(box.x, box.y); Serial.print("+");
  moveCursor(box.x + box.w - 1, box.y); Serial.print("+");
  moveCursor(box.x, box.y + box.h - 1); Serial.print("+");
  moveCursor(box.x + box.w - 1, box.y + box.h - 1); Serial.print("+");
}

// Draws a line using Bresenham's algorithm.
void draw(const Line& line) {
  int16_t x1 = line.x1, y1 = line.y1;
  const int16_t x2 = line.x2, y2 = line.y2;
  int16_t dx = abs(x2 - x1), sx = x1 < x2 ? 1 : -1;
  int16_t dy = -abs(y2 - y1), sy = y1 < y2 ? 1 : -1;
  int16_t err = dx + dy, e2;

  while (true) {
    moveCursor(x1, y1);
    Serial.print("#");
    if (x1 == x2 && y1 == y2) break;
    e2 = 2 * err;
    if (e2 >= dy) { err += dy; x1 += sx; }
    if (e2 <= dx) { err += dx; y1 += sy; }
  }
}

// Draws a string of text.
void draw(const Text& text) {
  moveCursor(text.x, text.y);
  Serial.print(text.content);
}

// =============================================================================
// == UI SCREEN DEFINITIONS (Generated by Python)
// =============================================================================

// [[SCREEN_FUNCTIONS_PLACEHOLDER]]

// =============================================================================
// == ARDUINO SETUP & LOOP
// =============================================================================

void setup() {
  Serial.begin(9600);
  // Wait for the serial port to connect (especially for native USB).
  while (!Serial) { delay(10); }

  delay(1000); // Give the serial monitor a moment to initialize.
  Serial.print("\\033[?25l"); // Hide cursor for a cleaner look.
  clearScreen();

  // Call the initial screen function.
  // [[INITIAL_SCREEN_CALL_PLACEHOLDER]]
}

void loop() {
  // Your interactive logic goes here.
  // For example, you could listen for commands over Serial to:
  // - Redraw a single object: draw(myButton);
  // - Switch to another screen:
  //   clearScreen();
  //   drawScreen_settings();
  delay(1000);
}
"""

# ==============================================================================
#  2. Python UI Object Representation
# ==============================================================================
# This class defines a UI object in Python and knows how to translate
# itself into the corresponding C++ struct definition.

class DrawableObject:
    """Represents a single drawable UI element."""
    def __init__(self, obj_type, name, data):
        # Basic validation to ensure the name is a valid C++ variable name.
        if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', name):
            raise ValueError(f"Object name '{name}' is not a valid C++ identifier.")
        self.obj_type = obj_type
        self.name = name
        self.data = data

    def to_cpp_declaration(self):
        """Generates the C++ code to declare and initialize the object's struct."""
        if self.obj_type == "box":
            x, y, w, h = self.data
            return f"  Box {self.name} = {{{x}, {y}, {w}, {h}}};"
        elif self.obj_type == "line":
            x1, y1, x2, y2 = self.data
            return f"  Line {self.name} = {{{x1}, {y1}, {x2}, {y2}}};"
        elif self.obj_type == "text":
            x, y, txt = self.data
            # Escape double quotes within the text string for C++
            escaped_txt = txt.replace('"', '\\"')
            return f'  Text {self.name} = {{{x}, {y}, "{escaped_txt}"}};'
        # Add other object types here
        return "  // Unsupported object type"

    def to_cpp_draw_call(self):
        """Generates the C++ code to call the draw() function for this object."""
        return f"  draw({self.name});"

# ==============================================================================
#  3. Code Generation Logic
# ==============================================================================
# This function takes the Python screen definitions, generates the C++ code,
# and injects it into the template.

def compile_to_cpp(screens, filename="ui_generated.ino"):
    """
    Generates a complete Arduino .ino file from a dictionary of screen objects.

    Args:
        screens (dict): A dictionary where keys are screen names and values are
                        lists of DrawableObject instances.
        filename (str): The name of the output file.
    """
    if not screens:
        print("Error: No screens defined. Nothing to compile.")
        return

    # --- Generate the C++ functions for each screen ---
    screen_functions_code = []
    for screen_name, objects in screens.items():
        # Sanitize screen_name to be a valid C++ function name
        function_name = f"drawScreen_{re.sub(r'[^a-zA-Z0-9_]', '', screen_name)}"

        # Start the function definition
        screen_functions_code.append(f"void {function_name}() {{")

        # Add object struct declarations
        for obj in objects:
            screen_functions_code.append(obj.to_cpp_declaration())

        # Add the draw calls
        screen_functions_code.append("") # Add a newline for readability
        for obj in objects:
            screen_functions_code.append(obj.to_cpp_draw_call())

        # Close the function
        screen_functions_code.append("}\n")

    generated_functions = "\n".join(screen_functions_code)

    # --- Determine the initial screen to draw in setup() ---
    # We'll just use the first screen defined in the dictionary.
    initial_screen_name = next(iter(screens))
    initial_call = f"drawScreen_{re.sub(r'[^a-zA-Z0-9_]', '', initial_screen_name)}();"

    # --- Inject generated code into the C++ template ---
    final_code = CPP_TEMPLATE.replace("// [[SCREEN_FUNCTIONS_PLACEHOLDER]]", generated_functions)
    final_code = final_code.replace("// [[INITIAL_SCREEN_CALL_PLACEHOLDER]]", initial_call)

    # --- Write the final code to the .ino file ---
    with open(filename, "w") as f:
        f.write(final_code)
    print(f"âœ… Arduino sketch successfully generated at '{filename}'")


# ==============================================================================
#  4. Main Execution: Define your UI screens here
# ==============================================================================

if __name__ == "__main__":
    # The main data structure to hold all UI screens and their objects.
    # Keys are screen names, values are lists of DrawableObject.
    ui_screens = {
        "main_menu": [
            DrawableObject("box", "windowFrame", (5, 2, 70, 20)),
            DrawableObject("text", "titleText", (30, 4, "--- MAIN MENU ---")),
            DrawableObject("line", "titleUnderline", (30, 5, 48, 5)),
            DrawableObject("box", "startButton", (32, 8, 16, 3)),
            DrawableObject("text", "startButtonLabel", (34, 9, "[ Start ]")),
            DrawableObject("box", "settingsButton", (32, 12, 16, 3)),
            DrawableObject("text", "settingsButtonLabel", (33, 13, "[ Settings ]")),
            DrawableObject("text", "footerText", (8, 20, "Send 's' for settings or 'q' to quit."))
        ],
        "settings": [
            DrawableObject("box", "settingsFrame", (10, 3, 50, 15)),
            DrawableObject("text", "settingsTitle", (25, 5, "--- SETTINGS ---")),
            DrawableObject("text", "brightnessLabel", (14, 8, "Brightness: ")),
            DrawableObject("line", "brightnessBar", (28, 8, 48, 8)),
            DrawableObject("text", "soundLabel", (14, 11, "Sound     : ")),
            DrawableObject("text", "soundValue", (28, 11, "[ ON ]")),
            DrawableObject("text", "backHint", (12, 16, "Send 'm' to return to main menu."))
        ]
    }

    # Generate the .ino file from our UI definition
    compile_to_cpp(ui_screens)
